use crate::maze::Maze;
use rand::{thread_rng, Rng};
// use termion::{clear, color, cursor};
//use std::thread::sleep;
//use std::time;

const IN: u8 = 0x10; // 0001 0000 16
const FRONTIER: u8 = 0x20; // 0010 0000 32

/// Generates a maze using Prim's algorithm
/// Prim’s approaches maze generation from a different angle. Rather than working edgewise across the
/// entire graph, it starts at one point, and grows outward from that point. The standard version
/// of the algorithm works something like this:
///
/// 1. Choose an arbitrary vertex from G (the graph), and add it to some (initially empty) set V.
/// 2. Choose a **random** edge from G, that connects a vertex in V with another vertex not in V.
/// 3. Add that edge to the minimal spanning tree, and the edge’s other vertex to V.
/// 4. Repeat steps 2 and 3 until V includes every vertex in G.
///
pub fn prims(width: usize, height: usize) -> Maze {
    let mut maze = Maze::new(width, height);
    let mut frontier: Vec<(usize, usize)> = vec![];

    // mark a random cell in the maze to begin at
    let x: usize = thread_rng().gen_range(0, width);
    let y: usize = thread_rng().gen_range(0, height);
    mark_in(&mut maze, &mut frontier, x, y);

    loop {
        if frontier.is_empty() {
            break;
        }

        // choose a random element in the frontier and remove it
        let ridx: usize = thread_rng().gen_range(0, frontier.len());
        let (x, y) = frontier.remove(ridx);

        // choose a random neighbor of the frontier cell that is "IN" the maze
        let n: Vec<(usize, usize)> = maze
            .neighbors(x, y)
            .into_iter()
            .filter(|&idxp| maze[[idxp.1, idxp.0]] & IN != 0)
            .collect();
        let nidx: usize = thread_rng().gen_range(0, n.len());
        let (nx, ny) = n[nidx];

        // carve a path from the current frontier cell to the random neighbor cell
        let dir = Maze::carve_passage(x, y, nx, ny);
        maze[[y, x]] |= dir as u8;
        maze[[ny, nx]] |= dir.opposite() as u8;
        mark_in(&mut maze, &mut frontier, x, y);
    }

    maze
}

/// add the x,y coordinates to the frontier list. Coordinates will only be added if they
/// are within the bounds of the Maze's grid and if the grid coordinate has not been visited
pub fn add_frontier(
    maze: &mut Maze,
    frontier: &mut Vec<(usize, usize)>,
    x: usize,
    y: usize,
) -> bool {
    if maze.in_bounds(x, y) && maze[[y, x]] == 0 {
        maze[[y, x]] |= FRONTIER;
        frontier.push((x, y));
        true
    } else {
        false
    }
}

/// mark a cell in the Maze as being "in" the maze (i.e. no longer in the frontier)
pub fn mark_in(maze: &mut Maze, frontier: &mut Vec<(usize, usize)>, x: usize, y: usize) {
    maze[[y, x]] |= IN;
    if x > 0 {
        add_frontier(maze, frontier, x - 1, y);
    }
    add_frontier(maze, frontier, x + 1, y);
    if y > 0 {
        add_frontier(maze, frontier, x, y - 1);
    }
    add_frontier(maze, frontier, x, y + 1);
}

// /// returns true if the specified cell has no walls carved out OR is part of the frontier
// fn empty(cell: &crate::maze::Cell) -> bool {
//     *cell == 0 || *cell == FRONTIER
// }

// #[allow(dead_code)]
// /// print the maze generated by Prim's algorithm to STDOUT
// pub fn display_maze(maze: &Maze) {
//     let top = " _".repeat(maze.width);
//     println!("{}", top);
//
//     for y in 0..maze.height {
//         print!("|");
//
//         for x in 0..maze.width {
//             if empty(&maze[[y, x]]) && y+1 < maze.height && empty(&maze[[y+1, x]]) {
//                 print!(" ");
//             } else {
//                 let c = if maze[[y, x]] & Direction::S as u8 != 0 { " " } else { "_" };
//                 print!("{}", c);
//             }
//
//             if empty(&maze[[y, x]]) && x+1 < maze.width && empty(&maze[[y, x+1]]) {
//                 let c = if y+1 < maze.height && (empty(&maze[[y+1, x]]) || empty(&maze[[y+1, x+1]])) { " " } else { "_" };
//                 print!("{}", c);
//             } else if maze[[y, x]] & Direction::E as u8 != 0 {
//                 let c = if ((maze[[y, x]] | maze[[y, x+1]]) & Direction::S as u8) != 0 { " " } else { "_" };
//                 print!("{}", c);
//             } else {
//                 print!("|");
//             }
//         };
//         println!();
//     }
// }

// /// Generates a maze using prim's algorithm and also displays each iteration of the algorithm
// /// to STDOUT. Frontier cells are colored in red.
// pub fn animated_prims(width: usize, height: usize) -> Maze {
//     let mut maze = Maze::new(width, height);
//     // clear the screen
//     print!("{}", clear::All );
//
//     // mark a random cell in the maze to begin at
//     let x: usize = thread_rng().gen_range(0, maze.width);
//     let y: usize = thread_rng().gen_range(0, maze.height);
//     maze.mark(x, y);
//
//     loop {
//         if maze.frontier.is_empty() {
//             break
//         }
//         // choose a random element in the frontier and remove it
//         let ridx: usize = thread_rng().gen_range(0, maze.frontier.len());
//         let (x,y) = maze.frontier.remove(ridx);
//
//         // choose a random neighbor to the current frontier cell
//         let n = maze.neighbors(x, y);
//         let nidx: usize = thread_rng().gen_range(0, n.len());
//         let (nx, ny) = n[nidx];
//
//         // carve a path from the current frontier cell to the random neighbor cell
//         let dir = Maze::direction(x, y, nx, ny);
//         maze.grid[y][x] |= dir as u8;
//         maze.grid[ny][nx] |= dir.opposite() as u8;
//
//         maze.mark(x, y);
//         display_maze( &maze );
//         sleep(time::Duration::from_millis(10))
//     }
//
//     display_maze(&maze);
//     maze
// }
