use rand::seq::IteratorRandom;
use rand::{thread_rng, Rng};
use crate::direction::Direction;
use crate::maze::Maze;
//use termion::{cursor, clear};
//use std::thread::sleep;
//use std::time::Duration;

/// The **recursive division** algorithm is a "wall adder". This algorithm is particularly
/// fascinating because of its fractal nature: you could theoretically continue the process
/// indefinitely at progressively finer and finer levels of detail.
///
/// It works like this:
///
/// 1. Begin with an empty field.
/// 2. Bisect the field with a wall, either horizontally or vertically. Add a single passage through the wall.
/// 3. Repeat step #2 with the areas on either side of the wall.
/// 4. Continue, recursively, until the maze reaches the desired resolution.


#[derive(Debug, Copy, Clone, PartialEq)]
#[repr(u8)]
pub enum Orientation {
    HORIZONTAL = 1,
    VERTICAL = 2,
}

/// returns a random usize between 0..max
fn rand(max: usize) -> usize {
    if max == 0 {
        0
    } else {
        thread_rng().gen_range(0, max)
    }
}

pub fn choose_orientation(width: usize, height: usize) -> Orientation {
    match (width, height) {
        (w, h) if w < h => Orientation::HORIZONTAL,
        (w, h) if h < w => Orientation::VERTICAL,
        (_, _) => *[Orientation::HORIZONTAL, Orientation::VERTICAL]
            .iter()
            .choose(&mut thread_rng()).unwrap()
    }
}

/// the actual recursive function used in recursive division
pub fn divide(
    maze: &mut Maze,
    x: usize,
    y: usize,
    width: usize,
    height: usize,
    orientation: Orientation,
) {
    if width < 2 || height < 2 {
        return;
    }

    // choose where wall will be drawn first
    let (mut wx, mut wy) = match orientation {
        Orientation::HORIZONTAL => (x, y + rand(height - 2)),
        Orientation::VERTICAL => (x + rand(width - 2), y),
    };

    // determine where the passage through the wall will exist
    let (px, py) = match orientation {
        Orientation::HORIZONTAL => (wx + rand(width), wy),
        Orientation::VERTICAL => (wx, wy + rand(height)),
    };

    // determine direction to draw the wall
    let (dx, dy): (usize, usize) = match orientation {
        Orientation::HORIZONTAL => (1, 0),
        Orientation::VERTICAL => (0, 1),
    };

    // compute wall length
    let length = match orientation {
        Orientation::HORIZONTAL => width,
        Orientation::VERTICAL => height,
    };

    // what direction is perpendicular to the wall?
    let dir = match orientation {
        Orientation::HORIZONTAL => Direction::S,
        Orientation::VERTICAL => Direction::E,
    };

    for _ in 0..length {
        if wx != px || wy != py {
            maze[[wy, wx]] |= dir as u8;
        }
        wx += dx;
        wy += dy;
    }

    let (w, h) = match orientation {
        Orientation::HORIZONTAL => (width, wy - y + 1),
        Orientation::VERTICAL => (wx - x + 1, height),
    };

    divide(maze, x, y, w, h, choose_orientation(w, h));

    let (nx, ny) = match orientation {
        Orientation::HORIZONTAL => (x, wy + 1),
        Orientation::VERTICAL => (wx + 1, y),
    };

    let (w, h) = match orientation {
        Orientation::HORIZONTAL => (width, y + height - wy - 1),
        Orientation::VERTICAL => (x + width - wx - 1, height),
    };

    divide(maze, nx, ny, w, h, choose_orientation(w, h));
}


/// generates and returns a maze using recursive division algorithm
pub fn recursive_divide(width: usize, height: usize) -> Maze {
    let mut maze = Maze::new(width, height);
    divide(
        &mut maze,
        0,
        0,
        width,
        height,
        choose_orientation(width, height),
    );
    maze
}


/// display a maze generated by recursive division to Standard Out
pub fn display_maze(maze: &Maze) {
    let top = " _".repeat(maze.width );
    println!("{}", top);

    for y in 0..maze.height {
        print!("|");

        for x in 0..maze.width {
            let on_last_row = y+1 >= maze.height;
            let has_south_wall = maze[[y, x]] & Direction::S as u8 != 0 || on_last_row;
            let adj_has_south = x+1 < maze.width && maze[[y,x+1]] & Direction::S as u8 != 0 || on_last_row;
            let has_east_wall = maze[[y, x]] & Direction::E as u8 != 0 || x+1 >= maze.width;

            if has_south_wall {
                print!("_");
            } else {
                print!(" ");
            }

            if has_east_wall {
                print!("|");
            } else {
                if has_south_wall && adj_has_south {
                    print!("_");
                } else {
                    print!(" ");
                }
            }
        }
        println!();
    }
}


